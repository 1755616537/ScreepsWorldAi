{
  "compilerOptions": {
    "target": "es2018",
    "moduleResolution": "Node",
    "outDir": "dist/",
    "baseUrl": "./",
    "sourceMap": true,
    "allowSyntheticDefaultImports": true,
    "paths": {
      "@/*": ["./src/*"]
    },
//    这个选项指定了模块解析策略。"esnext" 表示使用 ES2015+ 的模块系统，它允许你使用 import 和 export 语法
    "module": "esnext",
//    lib 配置项指定了编译过程中要包含的类型声明文件。"esnext" 表示你的项目将使用 ESNext 标准的库定义
    "lib": ["esnext","es6", "DOM"],
    "types": ["node", "lodash","reflect-metadata","@types/node","@types/lodash","@types/screeps"],
//    开启严格的类型检查模式，这包括了其他一些 strict 相关的子选项，如 noImplicitAny, noImplicitThis, alwaysStrict 等，以确保更安全和更一致的类型检查
//    "strict": true,
//    启用实验性的装饰器支持。装饰器是 ECMAScript 提案的一部分，用于修改类的行为或元数据
    "experimentalDecorators": true,
//    当使用装饰器时，此选项会在输出的 JavaScript 文件中添加必要的元数据，以便运行时可以访问到装饰器的信息
    "emitDecoratorMetadata": true,
//    确保每个函数都有返回语句。如果一个函数没有显式返回值，TypeScript 将会发出警告或错误
//    "noImplicitReturns": true,
//    禁止隐式的 any 类型。当 TypeScript 无法推断出类型时，它默认为 any 类型，这个选项会阻止这种行为并要求显式类型声明
//    "noImplicitAny": true,
//    在非严格模式下，this 关键字可能具有隐式的 any 类型。这个选项确保 this 总是有明确的类型
//    "noImplicitThis": true,
//    禁止在代码中存在不可达的代码段。例如，在 return 语句之后的代码被认为是不可达的
    "allowUnreachableCode": false,
//    允许编译器处理 .js 文件，通常用于与现有 JavaScript 代码库一起工作
    "allowJs": true,
//    禁止对未定义索引的类型进行无检查的访问。例如，尝试访问数组或对象的不存在的索引时，TypeScript 将发出警告
    "noUncheckedIndexedAccess": true
  },
  "exclude": [
    "node_modules",
    "src/Alliance/ThirdPartyCode/my-screeps-ai-master",
    "src/Alliance/ThirdPartyCode/screeps-typescript-starter-master"
  ],
  "include": [
    "src/**/*.ts"
  ]
}