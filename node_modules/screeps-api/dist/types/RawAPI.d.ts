export class RawAPI extends EventEmitter {
    constructor(opts?: {});
    raw: {
        /**
         * GET /api/version
         * @returns {{
         *  ok:1, package:number, protocol: number,
         *  serverData: {
         *    customObjectTypes,
         *    historyChunkSize:number,
         *    features,
         *    shards: string[]
         *  },
         *  users:number
         * }}
         */
        version(): {
            ok: 1;
            package: number;
            protocol: number;
            serverData: {
                customObjectTypes;
                historyChunkSize: number;
                features;
                shards: string[];
            };
            users: number;
        };
        /**
         * GET /api/authmod
         * @returns {Object}
         */
        authmod(): any;
        /**
         * Official:
         * GET /room-history/${shard}/${room}/${tick}.json
         * Private:
         * GET /room-history
         * @param {string} room
         * @param {number} tick
         * @param {string} shard
         * @returns {Object} A json file with history data
         */
        history(room: string, tick: number, shard?: string): any;
        servers: {
            /**
             * POST /api/servers/list
             * A list of community servers
             * @returns {{
             *  ok:number,
             *  servers:{
             *   _id:string,
             *   settings:{
             *     host:string,
             *     port:string,
             *     pass:string
             *   },
             *   name:string,
             *   status:"active"|string
             *   likeCount:number
             *  }[]
             * }}
             */
            list(): {
                ok: number;
                servers: {
                    _id: string;
                    settings: {
                        host: string;
                        port: string;
                        pass: string;
                    };
                    name: string;
                    status: "active" | string;
                    likeCount: number;
                }[];
            };
        };
        auth: {
            /**
             * POST /api/auth/signin
             * @param {string} email
             * @param {string} password
             * @returns {{ok:number, token:string}}
             */
            signin(email: string, password: string): {
                ok: number;
                token: string;
            };
            /**
             * POST /api/auth/steam-ticket
             * @param {*} ticket
             * @param {*} useNativeAuth
             * @returns {Object}
             */
            steamTicket(ticket: any, useNativeAuth?: any): any;
            /**
             * GET /api/auth/me
             * @returns {{
             *  ok: number;
             *  _id: string;
             *  email: string;
             *  username: string;
             *  cpu: number;
             *  badge: Badge;
             *  password: string;
             *  notifyPrefs: { sendOnline: any; errorsInterval: any; disabledOnMessages: any; disabled: any; interval: any };
             *  gcl: number;
             *  credits: number;
             *  lastChargeTime: any;
             *  lastTweetTime: any;
             *  github: { id: any; username: any };
             *  twitter: { username: string; followers_count: number };
             *}}
             */
            me(): {
                ok: number;
                _id: string;
                email: string;
                username: string;
                cpu: number;
                badge: Badge;
                password: string;
                notifyPrefs: {
                    sendOnline: any;
                    errorsInterval: any;
                    disabledOnMessages: any;
                    disabled: any;
                    interval: any;
                };
                gcl: number;
                credits: number;
                lastChargeTime: any;
                lastTweetTime: any;
                github: {
                    id: any;
                    username: any;
                };
                twitter: {
                    username: string;
                    followers_count: number;
                };
            };
            /**
             * GET /api/auth/query-token
             * @param {string} token
             * @returns {Object}
             */
            queryToken(token: string): any;
        };
        register: {
            /**
             * GET /api/register/check-email
             * @param {string} email
             * @returns {Object}
             */
            checkEmail(email: string): any;
            /**
             * GET /api/register/check-username
             * @param {string} username
             * @returns  {Object}
             */
            checkUsername(username: string): any;
            /**
             * POST /api/register/set-username
             * @param {string} username
             * @returns {Object}
             */
            setUsername(username: string): any;
            /**
             * POST /api/register/submit
             * @param {string} username
             * @param {string} email
             * @param {string} password
             * @param {*} modules
             * @returns {Object}
             */
            submit(username: string, email: string, password: string, modules: any): any;
        };
        userMessages: {
            /**
             * GET /api/user/messages/list?respondent={userId}
             * @param {string} respondent the long `_id` of the user, not the username
             * @returns {{ ok, messages: [ { _id, date, type, text, unread } ] }}
             */
            list(respondent: string): {
                ok;
                messages: [{
                    _id;
                    date;
                    type;
                    text;
                    unread;
                }];
            };
            /**
             * GET /api/user/messages/index
             * @returns {{ ok, messages: [ { _id, message: { _id, user, respondent, date, type, text, unread } } ], users: { <user's _id>: { _id, username, badge: Badge } } }}
             */
            index(): {
                ok: any;
                messages: [{
                    _id: any;
                    message: {
                        _id: any;
                        user: any;
                        respondent: any;
                        date: any;
                        type: any;
                        text: any;
                        unread: any;
                    };
                }];
                users: {
                    <user_1>(): any;
                    's _id>: { _id, username, badge: Badge } } }}': any;
                };
            };
            /**
             * GET /api/user/messages/unread-count
             * @returns {{ ok, count:number }}
             */
            unreadCount(): {
                ok;
                count: number;
            };
            /**
             * POST /api/user/messages/send
             * @param {string} respondent the long `_id` of the user, not the username
             * @param {string} text
             * @returns {{ ok }}
             */
            send(respondent: string, text: string): {
                ok;
            };
            /**
             * POST /api/user/messages/mark-read
             * @param {string} id
             * @returns {Object}
             */
            markRead(id: string): any;
        };
        game: {
            /**
             * @typedef {"creepsLost"|"creepsProduced"|"energyConstruction"|"energyControl"|"energyCreeps"|"energyHarvested"} stat
             * @param {string[]} rooms An array of room names
             * @param {"owner0"|"claim0"|stat} statName
             * @param {string} shard
             * @returns {{
             *  ok:number,
             *  stats: {
             *    [roomName:string]: {
             *      status,
             *      novice,
             *      own: { user, level },
             *      <stat>: [ { user, value }]
             *    }
             *  }
             * , users: { [userId:string]: { _id, username, badge: Badge } } }}
             * The return type is not mapped correctly
             */
            mapStats(rooms: string[], statName: "owner0" | "claim0" | ("creepsLost" | "creepsProduced" | "energyConstruction" | "energyControl" | "energyCreeps" | "energyHarvested"), shard?: string): {
                ok: number;
                stats: {
                    [roomName: string]: {
                        <stat_1>(): [{
                            user;
                            value;
                        }];
                        status: any;
                        novice: any;
                        own: {
                            user: any;
                            level: any;
                        };
                    };
                };
                users: {
                    [userId: string]: {
                        _id: any;
                        username: any;
                        badge: Badge;
                    };
                };
            };
            /**
             * POST /api/game/gen-unique-object-name
             * @param {"flag"|"spawn"|string} type can be at least "flag" or "spawn"
             * @param {string} shard
             * @returns { ok, name:string }
             */
            genUniqueObjectName(type: "flag" | "spawn" | string, shard?: string): any;
            /**
             * POST /api/game/check-unique-object-name
             * @param {string} type
             * @param {string} name
             * @param {string} shard
             * @returns {Object}
             */
            checkUniqueObjectName(type: string, name: string, shard?: string): any;
            /**
             * @param {string} room
             * @param {number} x
             * @param {number} y
             * @param {string} name
             * @param {string?} shard
             */
            placeSpawn(room: string, x: number, y: number, name: string, shard?: string | null): any;
            /**
             * POST /api/game/create-flag
             * @param {string} room
             * @param {number} x
             * @param {number} y
             * @param {string} name
             * @param {FlagColor} color
             * @param {FlagColor} secondaryColor
             * @param {string} shard
             * @returns {{ ok, result: { nModified, ok, upserted: [ { index, _id } ], n }, connection: { host, id, port } }}
             * - if the name is new, result.upserted[0]._id is the game id of the created flag
             * - if not, this moves the flag and the response does not contain the id (but the id doesn't change)
             * - `connection` looks like some internal MongoDB thing that is irrelevant to us
             */
            createFlag(room: string, x: number, y: number, name: string, color?: FlagColor, secondaryColor?: FlagColor, shard?: string): {
                ok;
                result: {
                    nModified;
                    ok;
                    upserted: [{
                        index;
                        _id;
                    }];
                    n;
                };
                connection: {
                    host;
                    id;
                    port;
                };
            };
            /**
             * POST/api/game/gen-unique-flag-name
             * @param {string} shard
             * @returns {Object}
             */
            genUniqueFlagName(shard?: string): any;
            /**
             * POST /api/game/check-unique-flag-name
             * @param {string} name
             * @param {string} shard
             * @returns {Object}
             */
            checkUniqueFlagName(name: string, shard?: string): any;
            /**
             * POST /api/game/change-flag-color
             * @param {FlagColor} color
             * @param {FlagColor} secondaryColor
             * @param {string} shard
             * @returns {{ ok, result: { nModified, ok, n }, connection: { host, id, port } }}
             */
            changeFlagColor(color?: FlagColor, secondaryColor?: FlagColor, shard?: string): {
                ok;
                result: {
                    nModified;
                    ok;
                    n;
                };
                connection: {
                    host;
                    id;
                    port;
                };
            };
            /**
             * POST /api/game/remove-flag
             * @param {string} room
             * @param {string} name
             * @param {string} shard
             * @returns {Object}
             */
            removeFlag(room: string, name: string, shard?: string): any;
            /**
             * POST /api/game/add-object-intent
             * [Missing parameter] _id is the game id of the object to affect (except for destroying structures), room is the name of the room it's in
             * this method is used for a variety of actions, depending on the `name` and `intent` parameters
             * @example remove flag: name = "remove", intent = {}
             * @example destroy structure: _id = "room", name = "destroyStructure", intent = [ {id: <structure id>, roomName, <room name>, user: <user id>} ]
    can destroy multiple structures at once
             * @example suicide creep: name = "suicide", intent = {id: <creep id>}
             * @example unclaim controller: name = "unclaim", intent = {id: <controller id>}
    intent can be an empty object for suicide and unclaim, but the web interface sends the id in it, as described
             * @example remove construction site: name = "remove", intent = {}
             * @param {string} room
             * @param {string} name
             * @param {string} intent
             * @param {string} shard
             * @returns {{ ok, result: { nModified, ok, upserted: [ { index, _id } ], n }, connection: { host, id, port } }}
             */
            addObjectIntent(room: string, name: string, intent: string, shard?: string): {
                ok;
                result: {
                    nModified;
                    ok;
                    upserted: [{
                        index;
                        _id;
                    }];
                    n;
                };
                connection: {
                    host;
                    id;
                    port;
                };
            };
            /**
             * POST /api/game/create-construction
             * @param {string} room
             * @param {number} x
             * @param {number} y
             * @param {string} structureType the same value as one of the in-game STRUCTURE_* constants ('road', 'spawn', etc.)
             * @param {string} name
             * @param {string} shard
             * @returns {{ ok, result: { ok, n }, ops: [ { type, room, x, y, structureType, user, progress, progressTotal, _id } ], insertedCount, insertedIds }}
             */
            createConstruction(room: string, x: number, y: number, structureType: string, name: string, shard?: string): {
                ok;
                result: {
                    ok;
                    n;
                };
                ops: [{
                    type;
                    room;
                    x;
                    y;
                    structureType;
                    user;
                    progress;
                    progressTotal;
                    _id;
                }];
                insertedCount;
                insertedIds;
            };
            /**
             * POST /api/game/set-notify-when-attacked
             * @param {string} _id
             * @param {bool} enabled is either true or false (literal values, not strings)
             * @param {string} shard
             * @returns {{ ok, result: { ok, nModified, n }, connection: { id, host, port } }}
             */
            setNotifyWhenAttacked(_id: string, enabled?: any, shard?: string): {
                ok;
                result: {
                    ok;
                    nModified;
                    n;
                };
                connection: {
                    id;
                    host;
                    port;
                };
            };
            /**
             * POST /api/game/create-invader
             * @param {string} room
             * @param {number} x
             * @param {number} y
             * @param {*} size
             * @param {*} type
             * @param {boolean} boosted
             * @param {string} shard
             * @returns {Object}
             */
            createInvader(room: string, x: number, y: number, size: any, type: any, boosted?: boolean, shard?: string): any;
            /**
             * POST /api/game/remove-invader
             * @param {string} _id
             * @param {string} shard
             * @returns {Object}
             */
            removeInvader(_id: string, shard?: string): any;
            /**
             * GET /api/game/time
             * @param {string} shard
             * @returns {{ ok:number, time:number }}
             */
            time(shard?: string): {
                ok: number;
                time: number;
            };
            /**
             * GET /api/game/world-size
             * @param {string} shard
             * @returns {Object}
             */
            worldSize(shard?: string): any;
            /**
             * GET /api/game/room-decorations
             * @param {string} room
             * @param {string} shard
             * @returns {Object}
             */
            roomDecorations(room: string, shard?: string): any;
            /**
             * GET /api/game/room-objects
             * @param {string} room
             * @param {string} shard
             * @returns {Object}
             */
            roomObjects(room: string, shard?: string): any;
            /**
             * @param {string} room
             * @param {*} encoded can be anything non-empty
             * @param {string} shard
             * @returns {{ ok, terrain: [ { room:string, x:number, y:number, type:"wall"|"swamp" } ] }
             * | { ok, terrain: [ { _id,room:string, terrain:string, type:"wall"|"swamp" } ] }}
             * terrain is a string of digits, giving the terrain left-to-right and top-to-bottom
             * 0: plain, 1: wall, 2: swamp, 3: also wall
             */
            roomTerrain(room: string, encoded?: any, shard?: string): {
                ok;
                terrain: [{
                    room: string;
                    x: number;
                    y: number;
                    type: "wall" | "swamp";
                }];
            } | {
                ok;
                terrain: [{
                    _id;
                    room: string;
                    terrain: string;
                    type: "wall" | "swamp";
                }];
            };
            /**
             * @param {string} room
             * @param {string} shard
             * @returns {{ _id, status:"normal"|"out of borders"|string, novice:string }}
             * `status` can at least be "normal" or "out of borders"
             * if the room is in a novice area, novice will contain the Unix timestamp of the end of the protection (otherwise it is absent)
             */
            roomStatus(room: string, shard?: string): {
                _id;
                status: "normal" | "out of borders" | string;
                novice: string;
            };
            /**
             * GET /api/game/room-overview
             * @param {string} room
             * @param {number} interval
             * @param {string} shard
             * @returns {Object}
             */
            roomOverview(room: string, interval?: number, shard?: string): any;
            market: {
                /**
                 * GET /api/game/market/orders-index
                 * @param {string} shard
                 * @returns {{ok:1,list:[{_id:string,count:number}]}}
                 * - _id is the resource type, and there will only be one of each type.
                 * - `count` is the number of orders.
                 */
                ordersIndex(shard?: string): {
                    ok: 1;
                    list: [{
                        _id: string;
                        count: number;
                    }];
                };
                /**
                 * GET /api/game/market/my-orders
                 * @returns {{ ok:number, list: [ { _id, created, user, active, type, amount, remainingAmount, resourceType, price, totalAmount, roomName } ] }}
                 * `resourceType` is one of the RESOURCE_* constants.
                 */
                myOrders(): {
                    ok: number;
                    list: [{
                        _id;
                        created;
                        user;
                        active;
                        type;
                        amount;
                        remainingAmount;
                        resourceType;
                        price;
                        totalAmount;
                        roomName;
                    }];
                };
                /**
                 * GET /api/game/market/orders
                 * @param {string} resourceType one of the RESOURCE_* constants.
                 * @param {string} shard
                 * @returns {{ ok:number, list: [ { _id, created, user, active, type, amount, remainingAmount, resourceType, price, totalAmount, roomName } ] }}
                 * `resourceType` is one of the RESOURCE_* constants.
                 */
                orders(resourceType: string, shard?: string): {
                    ok: number;
                    list: [{
                        _id;
                        created;
                        user;
                        active;
                        type;
                        amount;
                        remainingAmount;
                        resourceType;
                        price;
                        totalAmount;
                        roomName;
                    }];
                };
                /**
                 * GET /api/game/market/stats
                 * @param {*} resourceType
                 * @param {string} shard
                 * @returns {Object}
                 */
                stats(resourceType: any, shard?: string): any;
            };
            shards: {
                /**
                 * GET /api/game/shards/info
                 * @returns {{ok:number, shards:[{name:string,lastTicks:number[],cpuLimimt:number,rooms:number,users:number,tick:number}]}}
                 */
                info(): {
                    ok: number;
                    shards: [{
                        name: string;
                        lastTicks: number[];
                        cpuLimimt: number;
                        rooms: number;
                        users: number;
                        tick: number;
                    }];
                };
            };
        };
        leaderboard: {
            /**
             * GET /api/leaderboard/list
             * @param {number} limit
             * @param {"world"|"power"} mode
             * @param {number?} offset
             * @param {string?} season
             * @returns {{ ok, list: [ { _id, season, user, score, rank } ], count, users: { <user's _id>: { _id, username, badge: { type, color1, color2, color3, param, flip }, gcl } } }}
             */
            list(limit: number, mode: "world" | "power", offset: number | null, season: string | null): {
                ok: any;
                list: [{
                    _id: any;
                    season: any;
                    user: any;
                    score: any;
                    rank: any;
                }];
                count: any;
                users: {
                    <user_3>(): any;
                    's _id>: { _id, username, badge: { type, color1, color2, color3, param, flip }, gcl } } }}': any;
                };
            };
            /**
             * GET /api/leaderboard/find
             * @param {string} username
             * @param {"world"|string} mode
             * @param {string?} season An optional date in the format YYYY-MM, if not supplied all ranks in all seasons is returned.
             * @returns {{ ok, _id, season, user, score, rank }}
             * - `user` (not `_id`) is the user's _id, as returned by `me` and `user/find`
             * - `rank` is 0-based
             */
            find(username: string, mode?: "world" | string, season?: string | null): {
                ok;
                _id;
                season;
                user;
                score;
                rank;
            };
            /**
             * GET /api/leaderboard/seasons
             * @returns {{ ok, seasons: [ { _id, name, date } ] }}
             * The _id returned here is used for the season name in the other leaderboard calls
             */
            seasons(): {
                ok;
                seasons: [{
                    _id;
                    name;
                    date;
                }];
            };
        };
        user: {
            /**
             * @param {Badge} badge
             * @returns {{ ok?:number,error?:string}}
             */
            badge(badge: Badge): {
                ok?: number;
                error?: string;
            };
            /**
             * POST /api/user/respawn
             * @returns {Object}
             */
            respawn(): any;
            /**
             * POST /api/user/set-active-branch
             * @param {string} branch
             * @param {string} activeName
             * @returns {Object}
             */
            setActiveBranch(branch: string, activeName: string): any;
            /**
             * POST /api/user/clone-branch
             * @param {string} branch
             * @param {string} newName
             * @param {*} defaultModules
             * @returns {Object}
             */
            cloneBranch(branch: string, newName: string, defaultModules: any): any;
            /**
             * POST /api/user/delete-branch
             * @param {string} branch
             * @returns {Object}
             */
            deleteBranch(branch: string): any;
            /**
             * POST /api/user/notify-prefs
             * @param {*} prefs
             * @returns {Object}
             */
            notifyPrefs(prefs: any): any;
            /**
             * POST /api/user/tutorial-done
             * @returns {Object}
             */
            tutorialDone(): any;
            /**
             * POST /api/user/email
             * @param {string} email
             * @returns {Object}
             */
            email(email: string): any;
            /**
             * GET /api/user/world-start-room
             * @param {string} shard
             * @returns {Object}
             */
            worldStartRoom(shard: string): any;
            /**
             * returns a world status
             * - 'normal'
             * - 'lost' when you loose all your spawns
             * - 'empty' when you have respawned and not placed your spawn yet
             * @returns {{ ok: number; status: "normal" | "lost" | "empty" }} */
            worldStatus(): {
                ok: number;
                status: "normal" | "lost" | "empty";
            };
            /**
             * GET /api/user/branches
             * @returns {{ ok:number, list: [{
             *   _id: string;
             *   branch: string;
             *   activeWorld: boolean;
             *   activeSim: boolean;
             * }]}
             * }
             */
            branches(): {
                ok: number;
                list: [
                    {
                        _id: string;
                        branch: string;
                        activeWorld: boolean;
                        activeSim: boolean;
                    }
                ];
            };
            code: {
                /**
                 * GET /api/user/code
                 * for pushing or pulling code, as documented at http://support.screeps.com/hc/en-us/articles/203022612
                 * @param {string} branch
                 * @returns code
                 */
                get(branch: string): any;
                /**
                 * POST /api/user/code
                 * for pushing or pulling code, as documented at http://support.screeps.com/hc/en-us/articles/203022612
                 * @param {string} branch
                 * @param {*} modules
                 * @param {*} _hash
                 * @returns {Object}
                 */
                set(branch: string, modules: any, _hash: any): any;
            };
            decorations: {
                /**
                 * GET /api/user/decorations/inventory
                 * @returns {Object}
                 */
                inventory(): any;
                /**
                 * GET /api/user/decorations/themes
                 * @returns {Object}
                 */
                themes(): any;
                /**
                 * POST /api/user/decorations/convert
                 * @param {*} decorations decorations is a string array of ids
                 * @returns {Object}
                 */
                convert(decorations: any): any;
                /**
                 * POST /api/user/decorations/pixelize
                 * @param {number} count
                 * @param {string} theme
                 * @returns {Object}
                 */
                pixelize(count: number, theme?: string): any;
                /**
                 * POST /api/user/decorations/activate
                 * @param {string} _id
                 * @param {*} active
                 * @returns {Object}
                 */
                activate(_id: string, active: any): any;
                /**
                 * POST /api/user/decorations/deactivate
                 * @param {*} decorations decorations is a string array of ids
                 * @returns {Object}
                 */
                deactivate(decorations: any): any;
            };
            /**
             * GET /api/user/respawn-prohibited-rooms
             * @returns {{ ok, rooms: [  ] }}
             * - `room` is an array, but seems to always contain only one element
             */
            respawnProhibitedRooms(): {
                ok;
                rooms: [];
            };
            memory: {
                /**
                 * GET /api/user/memory?path={path}
                 * @param {string} path the path may be empty or absent to retrieve all of Memory, Example: flags.Flag1
                 * @param {string} shard
                 * @returns {string} gz: followed by base64-encoded gzipped JSON encoding of the requested memory path
                 */
                get(path: string, shard?: string): string;
                /**
                 * POST /api/user/memory
                 * @param {string} path the path may be empty or absent to retrieve all of Memory, Example: flags.Flag1
                 * @param {*} value
                 * @param {string} shard
                 * @returns {{ ok, result: { ok, n }, ops: [ { user, expression, hidden } ], data, insertedCount, insertedIds }}
                 */
                set(path: string, value: any, shard?: string): {
                    ok;
                    result: {
                        ok;
                        n;
                    };
                    ops: [{
                        user;
                        expression;
                        hidden;
                    }];
                    data;
                    insertedCount;
                    insertedIds;
                };
                segment: {
                    /**
                     * GET /api/user/memory-segment?segment=[0-99]
                     * @param {number} segment A number from 0-99
                     * @param {string} shard
                     * @returns {{ ok, data: string }}
                     */
                    get(segment: number, shard?: string): {
                        ok;
                        data: string;
                    };
                    /**
                     * POST /api/user/memory-segment
                     * @param {number} segment A number from 0-99
                     * @param {*} data
                     * @param {string} shard
                     * @returns {Object}
                     */
                    set(segment: number, data: any, shard?: string): any;
                };
            };
            /**
             * GET /api/user/find?username={username}
             * @param {string} username
             * @returns {{ ok, user: { _id, username, badge: Badge, gcl } }}
             */
            find(username: string): {
                ok;
                user: {
                    _id;
                    username;
                    badge: Badge;
                    gcl;
                };
            };
            /**
             * GET /api/user/find?id={userId}
             * @param {string} id
             * @returns {{ ok, user: { _id, username, badge: Badge, gcl } }}
             */
            findById(id: string): {
                ok;
                user: {
                    _id;
                    username;
                    badge: Badge;
                    gcl;
                };
            };
            /**
             * GET /api/user/stats
             * @param {number} interval
             * @returns {Object}
             */
            stats(interval: number): any;
            /**
             * GET /api/user/rooms
             * @param {string} id
             * @returns {Object}
             */
            rooms(id: string): any;
            /**
             * GET /api/user/overview?interval={interval}&statName={statName}
             * @param {number} interval
             * @param {string} statName energyControl
             * @returns {{{ ok, rooms: [ <room name> ], stats: { <room name>: [ { value, endTime } ] }, statsMax }}}
             */
            overview(interval: number, statName: string): {};
            /**
             * GET /api/user/money-history
             * @param {number} page Used for pagination
             * @returns {{"ok":1,"page":0,"list":[ { _id, date, tick, user, type, balance, change, market: {} } ] }}
             * - page used for pagination.
             * - hasMore is true if there are more pages to view.
             * - market
             *   - New Order- { order: { type, resourceType, price, totalAmount, roomName } }
             *   - Extended Order- { extendOrder: { orderId, addAmount } }
             *   - Fulfilled Order- { resourceType, roomName, targetRoomName, price, npc, amount }
             *   - Price Change - { changeOrderPrice: { orderId, oldPrice, newPrice } }
             */
            moneyHistory(page?: number): {
                "ok": 1;
                "page": 0;
                "list": [{
                    _id;
                    date;
                    tick;
                    user;
                    type;
                    balance;
                    change;
                    market: {};
                }];
            };
            /**
             * POST /api/user/console
             * @param {*} expression
             * @param {string} shard
             * @returns {{ ok, result: { ok, n }, ops: [ { user, expression, _id } ], insertedCount, insertedIds: [ <mongodb id> ] }}
             */
            console(expression: any, shard?: string): {
                ok: any;
                result: {
                    ok: any;
                    n: any;
                };
                ops: [{
                    user: any;
                    expression: any;
                    _id: any;
                }];
                insertedCount: any;
                insertedIds: [<mongodb_1, id_1>() => any];
            };
            /**
             * GET /api/user/name
             * @returns {Object}
             */
            name(): any;
        };
        experimental: {
            /**
             * @param {number} interval
             * @returns {{ ok, time, rooms: [ { _id, lastPvpTime } ] }}
             * time is the current server tick
             * _id contains the room name for each room, and lastPvpTime contains the last tick pvp occurred
             * if neither a valid interval nor a valid start argument is provided, the result of the call is still ok, but with an empty rooms array.
             */
            pvp(interval?: number): {
                ok;
                time;
                rooms: [{
                    _id;
                    lastPvpTime;
                }];
            };
            /**
             * GET /api/experimental/nukes
             * @returns {Object}
             */
            nukes(): any;
        };
        warpath: {
            /**
             * GET /api/warpath/battles
             * @param {number} interval
             * @returns {Object}
             */
            battles(interval?: number): any;
        };
        scoreboard: {
            /**
             * GET /api/scoreboard/list
             * @param {number} limit
             * @param {number} offset
             * @returns {Object}
             */
            list(limit?: number, offset?: number): any;
        };
    };
    currentSeason(): string;
    isOfficialServer(): boolean;
    mapToShard(res: any): any;
    setServer(opts: any): void;
    opts: {};
    token: any;
    http: import("axios").AxiosInstance;
    auth(email: any, password: any, opts?: {}): Promise<{
        ok: number;
        token: string;
    }>;
    __authed: boolean;
    req(method: any, path: any, body?: {}): any;
    gz(data: any): Promise<any>;
    inflate(data: any): Promise<any>;
    buildRateLimit(method: any, path: any, res: any): {
        method: any;
        path: any;
        limit: number;
        remaining: number;
        reset: number;
        toReset: number;
    };
}
export type Badge = {
    "color1": string;
    "color2": string;
    "color3": string;
    "flip": boolean;
    "param": number;
    "type": number | {
        path1: string;
        path2: string;
    };
};
/**
 * - Red = 1,
 * - Purple = 2,
 * - Blue = 3,
 * - Cyan = 4,
 * - Green = 5,
 * - Yellow = 6,
 * - Orange = 7,
 * - Brown = 8,
 * - Grey = 9,
 * - White = 10
 */
export type FlagColor = 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10;
import { EventEmitter } from "events";
